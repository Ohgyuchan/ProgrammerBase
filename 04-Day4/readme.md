# Day 4 

GBC 첫번째 과정 **Programmer Base** 의 4일차 내용입니다.

---

# CLI

**CLI** 란 **Command Line Interface** 의 줄임말로써 말 그대로 터미널 인터페이스만 제공하는 프로그램을 뜻합니다. 반대로 **GUI**, 즉 **Graphic User Interface** 에는 우리가 이미 익숙해져 있습니다. 카카오톡, 배틀그라운드, 한컴, 파워포인트, `VSCode` 같은 게 전부 다 **GUI** 이기 때문이죠. 

여기에서는 다양한 **CLI** 들을 알아보고 지금까지 배웠던 몇몇 **CLI** 들은 업그레이드를 해보겠습니다.

# Funny CLI 

[funny](funny.md)

---

# tmux, gdb, xxd, hd

# 쉘 스크립트 

하지만 MIT 에서 왠만하면 쉘 스크립트 쓰지 말라헀던 포스트 게시.

---

# CLI 업그레이드하기

> 참고 : https://wiki.archlinux.org/index.php/Core_utilities#Alternatives

> +++ MIT 미싱 클래스 

여러분은 지금까지 리눅스 교재와 이곳의 내용들을 통해서 `bash` 쉘, `git`, `find`, `cat`, `ls`, `vim`, `tmux`, `gdb` 같은 CLI 툴을 알아보았습니다. 

하지만 지금부터 이 CLI 툴들을 사용하기 편리하도록 업그레이드 해보겠습니다. 그러기 위해서 먼저 다음의 명령어들을 입력해서 각각의 툴들을 먼저 업그레이드 해놓겠습니다. 

```shell
$ sudo apt-get -y -qq install git zsh vim tmux unzip curl wget 
$ ZIPFILE="fd.deb"
$ VERSION=`curl -s https://github.com/sharkdp/fd/releases/latest | cut -d '"' -f 2 | cut -d '/' -f 8`
$ wget -q -O $ZIPFILE -q https://github.com/sharkdp/fd/releases/download/$VERSION/fd_${VERSION:1}_amd64.deb
$ sudo dpkg -i $ZIPFILE
$ DEBFILE="bat.deb"
$ VERSION=`curl -s https://github.com/sharkdp/bat/releases/latest | cut -d '"' -f 2 | cut -d '/' -f 8`
$ wget -q -O $DEBFILE -q https://github.com/sharkdp/bat/releases/download/$VERSION/bat_${VERSION:1}_amd64.deb
$ sudo dpkg -i $DEBFILE
$ DEBFILE="lsd.deb"
$ VERSION=`curl -s https://github.com/Peltoche/lsd/releases/latest | cut -d '"' -f 2 | cut -d '/' -f 8`
$ wget -q -O $DEBFILE -q https://github.com/Peltoche/lsd/releases/download/$VERSION/lsd_${VERSION}_amd64.deb
$ sudo dpkg -i $DEBFILE
$ wget -q "https://github.com/sharkdp/hexyl/releases/download/v0.6.0/hexyl_0.6.0_amd64.deb"
$ sudo dpkg -i hexyl_0.6.0_amd64.deb
$ wget -q -O install_ohmyzsh.sh https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh
$ sh install_ohmyzsh.sh --unattended
$ rm install_ohmyzsh.sh
$ git clone -q --recurse-submodules https://github.com/eendroroy/alien-minimal.git ~/.oh-my-zsh/custom/themes/alien-minimal
$ git clone -q https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/plugins/zsh-autosuggestions
$ curl -sfLo ~/.vim/autoload/onedark.vim --create-dirs https://raw.githubusercontent.com/joshdick/onedark.vim/master/autoload/onedark.vim
$ curl -sfLo ~/.vim/colors/onedark.vim --create-dirs https://raw.githubusercontent.com/joshdick/onedark.vim/master/colors/onedark.vim
$ curl -sfLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
$ vim +PlugInstall +qall
```

하지만 이 명령어들을 다 입력하라니.. 정말 의욕이 사라지지 않나요? 그래서 제가 이것을 한 방에 설치할 수 있도록 쉘스크립트를 만들어두었습니다. 

이러한 CLI 툴들의 설치와 설정들을 매번 설치하기가 너무 귀찮아서 죽을 수도 있기 때문에 사람들은 `dotfiles` 라는 이름의 레포지토리에 일관적으로 정리해놓습니다. 

> 대표적으로 https://github.com/jessfraz/dotfiles, https://github.com/jessfraz/.vim 같은 레포지토리가 유명한 `dotfiles` 레포지토리입니다. 이렇게 개인적인 설정과 개인적인 CLI 툴 업그레이드를 만들어주어도, 사람들이 그것을 보고 사용하다가 편리하면 그냥 갖다 쓰기도 합니다. 

그럼 이제 다음 명령어를 통하여 저의 `dotfiles` 를 통해 CLI 들을 업그레이드해보겠습니다.

> 물론 여러분도 툴들을 사용하면서 개인적으로 업그레이드하고 싶은 부분이나 마음에 드는 설정을 `dotfiles` 레포지토리에 저장해놓을 수 있습니다.

##### **<div align="center"> ⬇ EXECUTE! ⬇ </div>**

```shell
$ git clone https://github.com/ccss17/dotfiles-cli
$ cd dotfiles-cli
$ ./install.sh
```

그리고 다음 다시 도커 컨테이너에 접속해보세요. 

> 컨테이너 아이디 `e7bdf01c0acb` 는 다들 다를거에요.

##### **<div align="center"> ⬇ EXECUTE! ⬇ </div>**

```shell
$ exit
$ docker ps -a 
CONTAINER ID        IMAGE                      COMMAND                  CREATED              STATUS                     PORTS               NAMES
e7bdf01c0acb        ccss17/ubuntu              "/start.sh"              About a minute ago   Exited (0) 2 seconds ago                       hungry_albattani
$ docker start -ai e
```

그러면 더 이상 `bash` 가 아닌 `zsh` 쉘로 로그인 되고 모든 CLI 들과 설정들이 업그레이드된 환경이 자동으로 세팅되어 있습니다.

> 물론 일반적인 시스템에서 `zsh` 을 설치하고 나면 `chsh -s /usr/bin/zsh` 명령어로 기본쉘을 변경해주어야 합니다. 

이제 어떻게 업그레이드 되었는지, 그리고 얼마나 편리해졌는지 하나씩 알아보겠습니다. 

## `cat` ➜ `bat`

**[`bat`](https://github.com/Peltoche/lsd)** 는 구식인 `cat` 명령어를 최신식으로 대체한 프로그램입니다. 그럼 `cat` 와 `bat` 를 비교해봅시다. 


## `ls` ➜ `lsd`

**[`lsd`](https://github.com/Peltoche/lsd)** 는 구식인 `ls` 명령어를 최신식으로 대체한 프로그램입니다. 그럼 `ls` 와 `lsd` 를 비교해봅시다. 

##### **<div align="center"> ⬇ EXECUTE! ⬇ </div>**

```shell
$ /bin/ls
$ /bin/ls -l
$ /bin/ls -al
$ lsd
$ lsd -l
$ lsd -al
```

그러면 실행결과가 다음과 같을 겁니다.

![캡처](https://user-images.githubusercontent.com/16812446/81680218-d0a51200-948d-11ea-8405-7611ef675fdd.PNG)

이렇게 컬러풀하게 출력결과를 보여줘서 가독성이 훨씬 올려줍니다. 

그런데 `lsd` 를 설치했기 때문에 `ls` 를 더 이상 쓰지 않을 거라서 `~/.zsh_aliases` 에서 `lsd` 의 `alias` 를 지정해주었습니다. 

> `alias` 는 리눅스 교재에서 다들 공부했을 거라고 믿습니다. 


## `bash` ➜ `zsh`

`zsh` 은 수많은 플러그인과 테마가 지원되는 쉘입니다. 이제 `bash` 쉘을 그만 쓰고 `zsh` 을 사용해보겠습니다.

> `zsh` 의 기능이 하도 많아서 `zsh` 를 사용하는 저도 기능의 반의 반도 알지 못하지만 다시는 `bash` 를 쓸 수 없게 되었습니다. `zsh` 이 너무 편하기 때문이죠. 

> 2019년에 출시된 **macOS Catalina**에서도 `bash` 를 버리고 `zsh` 을 기본쉘로 채택했다니까 맥유저들은 `zsh` 기능을 알면 더욱 좋겠네요. 

> `zsh` 말고도 [**`fish`**](https://fishshell.com/) 쉘도 많이 쓰입니다. 

### 테마

`zsh` 은 정말 수많은 테마를 갖고 있습니다. https://github.com/ohmyzsh/ohmyzsh/wiki/External-themes 에 들어가서 어떤 테마들이 있는지 한번 봐보세요. 

우리가 사용할 `zsh` 테마는 다음과 같은 [alien-minimal](https://github.com/eendroroy/alien-minimal) 입니다.

[![asciicast](http://asciinema.org/a/264037.svg)](https://asciinema.org/a/264037)

`zsh` 테마는 단순히 `bash` 쉘 프롬프트보다 더 멋있기 때문에 사용해야 하는 것도 있지만 수많은 기능들도 제공하기 때문에 사용해야 합니다.

-


### `z` 명령어 

### `auto complete` 기능

## `vim`

[vim.md](vim.md)

![](../modify_value.gif)

## `tmux`, `ssh`, lsd, exa, fd, .....

- 매니저 스크립트 만들고 이런 최신기술을 클린코더 말투로 몰랐나요, 몰랐다면 왜 몰랐습니까? 라며 건전한 비판. 

  - bash 쉘을 전쟁터에 나갈 떄 칼과 화살을 갖고 가는 것. 도전을 주기 위해 하는 것..

---

# 리눅스 교재

교재에서 다음 분량을 읽고 우분투 도커 컨테이너에서 실습해주세요. 사실 너무 열심히 읽지 않아도 됩니다. 즉, 막 외우려고 애쓰지 않아도 된다는 뜻입니다. 다만 꼭 "정독" 을 하시고 한번쯤 책에 있는 실습을 따라해주세요. 

**(옵션)** 라고 되어있는 파트는 시간절약을 위해 넘겨도 됩니다.

## Chapter 06

- **276p ~ 290p, 292p ~ 295p 읽고 실습하기**

  - 프로세스의 개념, 프로세스 관리 명령

- **296p ~ 301p 읽고 실습하기**

  - 포그라운드/백그라운드 프로세스와 작업 제어, 

- **304p ~ 315p 읽고 실습하기**

  - **(옵션)** 작업 예약

---

# (기존 GBC) Ch06 Ch07 파일 시스템과 디스크 관리

# (기존 GBC) Ch08 리눅스 부팅과 종료, Ch10 사용자 관리

# `slack`

# 유닉스 필로 소피 
  
# 코딩 컨벤션 (유닉스 필로소피)

  - suckless 스타일
  
  - googld 코딩 스타일 

    https://www.google.com/search?client=firefox-b-d&q=unix+philosophy

    https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch01s06.html

    https://www.kernel.org/doc/Documentation/process/coding-style.rst

    https://man.openbsd.org/style

    https://www.google.com/search?client=firefox-b-d&q=google+coding+style

    https://github.com/google/styleguide/blob/gh-pages/pyguide.md

    그럼 처음으로 다뤄볼 주제는 코딩 컨벤션입니다. 코딩 컨벤션은, 프로그래밍 스타일에 대한 가이드라인입니다. 프로그래밍 스타일, 즉 코딩 스타일은 코드를 어떻게 작성할지에 관한 규칙입니다. 코딩 스타일은 코드의 기능에 실질적으로 영향을 주지는 않지만 코드의 가독성을 높혀주고 유지보수성을 높혀줍니다.

    대표적으로 indentation style, vertical alignment, spaces style, tabs style 등이 있습니다.

    indentation style 이란 코드의 블록과 컨트롤 플로우를 어떻게 쓸지 결정하죠.
    가령 간단한 if-else 문을 생각해 봅시다.
    코딩 스타일을 통일하지 않고 if-else 문을 사용한다면,
    어떤 함수에서는 이렇게 사용했다가 
        if ( hours < 24 && minutes < 60 && seconds < 60) { return true; } 
        else { return false; }
    어떤 함수에서는 이렇게 사용할 수도 있겠죠
        if ( hours < 24 && minutes < 60 && seconds < 60) {
            return true;
        } else { 
            return false; 
        }
    하지만 이렇게 코딩 스타일을 통일하지 않으면 프로젝트가 계속해서 커져갈 때마다 가독성이
    떨어집니다. 저렇게 if-else 문의 모양새가 다른 것들이 10개, 100개, 1000개가 된다면 말이죠.
        
    그래서 이런 스타일로 통일하거나,

        if (hours < 24 && minutes < 60 && seconds < 60) {
            return true;
        } else {
            return false;
        }

    이런 스타일로 통일해야 합니다.

        if (hours < 24 && minutes < 60 && seconds < 60)
        {
            return true;
        }
        else
        {
            return false;
        }

    그럼 대표적인 코딩 스타일들을 비교해볼까요?
    (참고 : https://github.com/motine/cppstylelineup)

### ekfms 

.gitignore 도 설명

(다른 사람이 올린 레포지토리 갖고 오기)
(pull requests, hguapp.ghoster.cc./git/)

# markdown 파일

- `markdown` 파일 사용법

- hguapp.ghoster.cc/git/ 과 github.com/ccss17 에서 내가 이미 올려둔 markdown 예시 보여주기

- {USERID}.github.io 사용법 알려주기 (다른 날에 해도 됨)

  - 예시로 내가 수학공식 올리던거 알려주기

## readme.md 파일

# 구글 검색 

  - [플랫폼] [동사] [목적어] 머 이런식으로 검색해바라

  - 영어로 검색할 시 이점 설득 

# 기술의 역사

- 괴델 불완전성 정리 -> 물질화/격하

- 프로그래밍 역사 

- 해킹 / 웹해킹 시스템해킹 안드로이드해킹

- 소프트웨어 개발 분야 소개 / 웹 앱 게임 시스템 백엔드 머신러닝 프리랜서

- C C++ Java Kotlin Rust 등 인기있는 언어의 변화 과정 / 최신 언어를 알아야 뒤쳐지지 않음

- NodeJS JSP xml php go Spring 웹 개발 발달 과정을 이해해야 함

# 코딩 테스트 사이트 

- 백준, 렛코드, 카카오, 삼성 

### CTF 사이트 

- 설명 및 소개 

# 기술의 역사 

- (주목 끌기) 여러분 유튜브 처음부터 보시죠. 왜 처음부터 보십니까. 인과관계 때문에 그러지 않습니까. 뒤에서부터 보는 사람은 아무도 없죠. 내용을 이해하지 못하니까요.

  - 그렇다면 컴퓨터 공학을 공부해야 하는 우리의 입장에서 어째서 그 인과관계를 염두해두고 최초의 원인부터 공부하지 않스빈까? 

  - 다시 물어보겠습니다. 어떤 대상이든간에 그 대상은 그 대상을 낳은 원인에 귀속됩니다. 그래서 쉽게 말하면 여러분 유튜브나 영화 볼 때도 처음부터 보는 것이고, 어떤 사람에 대하여 이해하고 싶을 때 그사람의 과거를 알기 원하게 되죠. 그렇다면 컴퓨터 공학을 제대로 이햏가ㅗ 싶다면 컴퓨터 공학의 과거를 알아야죠! 그것이 탄생한 시초부터, 그것의 본질와 원류를 이해해야죠.

  - 컴퓨터를 발생시킨 것은 튜링의 이론적 모델이었기 때문이죠.

  - 튜링의 이론적 모델은 괴델의 불완전성 정리에서 착안한 것이죠. 

  - 괴델의 불완정성 정리가 왜나왔스빈까. 수학의 기초, 즉 2천년동안 사람들이 미덩왔던 수학의 공리적 연역 방식이 통쨰로 의심받았기 때문이죠. 

  - 그러면 어쩌다가 수학의 기초가 의심받아싼요? 그것은 수학사를 찬찬히 읽어보면 알게되죠. 

  - 저는 휴학하는 동안 시간이 남아서 수학사상사 3권과 수학의 확실성을 읽어었요 이게 수학사에 해당합니다.

  - 그다음 저는 괴델의 정리라는 책을 읽었죠. 이게 괴델의 불완전성 정리에 해당하니다. 

    - 이때 괴델이 메타 수학 명제를 수학 명제로 격하시키는 것에 대한 설명 

    - 이 수학적 논증법으로 탄생한 컴퓨터 또한 메타 수학 명제를 수학 명제로 격하시키는 프로그래밍이라는 과정을 하는 것임!!!!!!!!!!!!!!!!! ( 이 부분 매우 매우 강조 )

      - 많은 예시를 들어서 이 부분 강하게 설득.

      - 단, 컴퓨터는 괴델의 불완전성 정리에서 메타 수학 명제를 수학 명제로 격하시키는 것과 약~~간은 다르게 튜링 머신에서 세상에 존재하는 어떤 기계도 텍스트로 변환할 수 있고 그 텍스트를 흉내낼 수 있는 대상임. 

      - 예시 

        무한대 서점이 망한 이야기. 즉, "서점에서 책을 사고 판다" 라는 명제를 수학 명제로 격하시키는 것임. 결국에 프로그래밍으로 "서점에서 책을 사고 판다" 는 명제를 완전한 수학 명제로 격하시키는 과정 보여줌. 

      - 예시 

        심지어 더 나아가서 감각기관을 수학 명제로 격하시키는 예시 보여줌. 그떄 하진이에게는 과도한 사고 실험과 뇌피셜로 설명했었지만, 컴퓨터 비전이라는 특정 분야에 대한 기술적 설명을 곁들여서 설득력있게 "시각적 감각기관" 을 수학명제로 격하시키는 것을 설득력있게 보여주자. OpenCV 로. 
      
      - 이러한 격하가 가능한 것은 "변환" 과 "대체" 가능하기 때문. 

        - 이 "변환" 과 "대체" 라는 두 키워드를 강하게 어필하자. 

        - 예시 

          사고 실험을 하나 해보겠습니다. 밤에 잘을 잘때 저는 불을 끄러 스위치를 내려야 합니다. 하지만 잠을 자고 싶을 떄면 저는 항상 몸이 많이 피곤해서 침대에 누운 상태였죠. 그럼에도 불구하고 침대에 누운 상태에서 스위치를 내리고 싶어서 그럴 수 있는 방법이 있는지 고민했어요. 결국 한 가지 아이디어를 떠올렸는데 침대 옆에 일종의 지렛대를 만들고 스위치까지 연결되게 한 다음 그 지렛대에 힘을 가하면 스위치까지 힘이 전달되도록 하는 기계를 만드는 것입니다. 

          그러면 이 기계는 "스위치를 내리는 행위" 를 대체할 수 있게 되었습니다. 대체할 수 있게 된 것은 힘을 변환(사상)시킬 수 있었기 때문입니다. 

          이제 이런 기술공학물을 프로그래밍으로 연결시켜보겠습니다. 시간이 흘러서 IoT 프로그래밍, 안드로이드 어플리케이션 프로그래밍을 배운 저는 지렛대로 힘을 변환하는 것보다 훨씬 세련된 방법이 있다는 것을 알았습니다. 그리고 스위치를 변환하는 장치를 IoT 시스템에 연결하고 안드로이드 어플리케이션을 하나 만들어서 스마트폰 버튼을 누름으로써 신호를 IoT 서버에 전달하고 IoT 서버는 다시 그 신호를 스위치로 전달하여 스위치를 내릴 수 있게 한 거죠. 

          이것으로 "스마트폰 버튼을 누르는 행위" 가 "정전기" 로 변환되고 "정전기" 는 스마트폰 스크린 좌표 신호로 변환되어 어플리케이션으로 전달되고 어플리케이션은 그 전기자극을 서버로 전달하고 서버는 다시 스위치로 전기자극을 전달해서 스위치를 내리게 되었습니다. 변환 형태가 지렛대와 비교하여 좀 달라졌지만 똑같이 "스위치를 누르는 행위" 를 기술 공학물로 대체할 수 있게 되었죠. 
        
        - 이런 통찰력이 있다면 여러분은 여러분이 다른 사람보다 더 잘 이해하고 있는 분야에 여러분만의 기술 공학물을 만들 수 있습니다.

          이 "변환" 과 "대체" 로 사람이 서로 대화하는 것을 수학 명제로 격하 시킬 수 있겠다 란느 아이디어를 내었던 사람들도 있었죠. 

          그게 뭔지 아십니까? 그게 카카오톡입니다. 이제 좀 실감이 나시나요? 
        
        - 우리 프로그래머는 코드로써 자연적 대상을 수학 명제로 격하시켜서 변환하고 대체할 수 있는 것입니다. 

          - 가령 이 "변환" 과 "대체" 로 인간이 이동하는 행위도 대체할 수 있습니다. 그게 뭐지 아십니까/ 그게 자동차입니다.
          
            자동차 공학자들은 인간의 이동하는 행위를 변환하고 대체하였죠! 

            자동차 공학자들은 인간이 걷는 행위에 들어가는 힘을, 페달을 밟는 행위로 변환했습니다. 이로써 페달을 밟는 것인 자동차 엔진을 작동시키고 엔진은 연료를 소모하여 동력을 얻어내고 그 동력이 바퀴를 굴러가게 해서 결국 인간이 페달만 밟아도 이동할 수 있도록 이동 행위를 대체할 수 있었습니다. 
      
        - 그러면 인간의 지능을 프로그램으로 대체할 수도 있지 않을까 라는 생각도 충분히 할 수 있죠? 

          만약 인간의 지능을 기계로 대체하여 자동화할 수 있다면 자동차라는 기계가 우리에게 주는 편의를 동일하게 받을 수 있겠지요? 인간이 끝없이 이동하면 지치는 것과 달리 자동차는 끝없이 이동해도 지지ㅣ 않으니까, 만약 인간의 생각, 학습, 성장, 고민, 지성 활동을 대체한다면 인간이 끝없이 공부하고 학문을 발전시키면 지치는 것과 달리 프로그램은 지치지 않겠지요? 

          그러면 한 가지 고민을 할 수 있습니다. 인간의 뇌의 구조가 뭐고 생각의 원리란 뭘까? 만약 그 뇌의 구조를 밝혀낼 수 있고 생각의 원리를 규명할 수 있다면 수학 명제로 격하시킬 수 있을 것이고, 인공적인 지능을 만들 수 있을텐데!

          또 다시 동일하게 "변환" 과 "대체" 라는 원리를 적용해볼 수 있습니다. 뇌과학에서는 인간의 뇌를 구성하는 뉴런의 동작 원리를 규명해놓았습니다. 이 동작 원리가 규명되었으니 곧 바로 그것을 수학 명제로 변환하여 지능을 대체할 수 있었습니다. 그게 바로 퍼셉트론입니다. 
        
          인공지능 신경망이 뭔지 아십니까? 그것은 뇌과학에서 밝힌 뇌 속의 뉴런을 퍼셉트론으로 변환하여 대체한 것입니다. 이 퍼셉트론으로 신경망ㅇ르 만들고 인간의 뇌의 뉴런들의 네트워크를 흉내낼 수 있엇습ㄴ다. 그 결과 아직 부분적이고 불완전하지만 인공적으로 인간의 지성 활동을 흉내낼 수 있었고 그것을 결국 인공지능이라 부를 수 있게 되었습니다. 이 인공지능이 오늘날 글자도 알아맞추고 운전도 스스로 하고 동영상 추천까지 해줍니다. 
        
        - 자, 오늘은 여기까지이고 이제 제가 만든 프로그램으로써 "변화" 과 "대체" 의 자세한 예시를 들어주겠습니다. "네모로직을 해결하는 인간의 사유과정" 을 수학명제로 격하시키고 이것을 프로그램으로까지 변환시켜서 대체하는 예시입니다. 

          - 이것은 안들으실 분들은 안들으셔도 되요! 수업은 이미 끝났습니다. 회의는 여기까지입니다. 
        
        - 이뿐 아니라 심지어 "컴퓨터를 사용하는 특정 행위" 또한 자동화 될 수 있다는 것을 아시나요? --> 수강신청 자동화.. 
      
      - 저는 이것을 아는 것이 프로그래머로써 정말 기본이라고 생각합니다. 프로그래머도 기술 공학자에요. 그러니까 여러분도 기술 공학자인 것입니다. 어떤 공학물을 만들려 하십니까? 어 나는 우리 아버지가 세금 계산을 하시는데 그 세금 계산이 하루에도 정말 수백 수천번 계산을 해야 해서... 그것을 자동화시키려 한다. 그러면 그 계산 행위를 명확하게 규명한 다음 수학 명제로 변환시키면 되죠. 

        자동화시키고 싶은 자연 대상을 단순화시킨 다음 수학 명제로 직접적으로 대응될 때까지 닩순화시키면, 그떄부터는 프로그램으로 변환시키기가 너무 쉬워지는 거죠. 
      
      - 하지만 영국 "   " 에서는 이 자동화에 관하여 경고했어요. 

      - 이 자동화의 끝에 기술적 특이점이 올것이다.. 이 기술적 특이점에 관하여서는 내일 얘기하겠습니다. 

        - 기술적 특이점은 SF 소설에 등장하는 이야기도 아니고 제 머리속에서 나온 뇌피셜도 아닙니ㅏ. 저명하고 위대한 수학자들이 수많은 고려 끝에 진중한 어조로 경고한 인류 역사상 가장 큰 변혁점입니다. 

        - 이 특이점을 언급함 최초의 인물은 폰 노이만입니다. 

        - 기술적 특이점이 대중에게 최초로 널리 알려지게 된 계기는 빌 조이의 "우리는 왜 필요없는 존재가 될 것인가?" 란느 블로그 글 때문이었습니다. 정말 추천합니다. 꼭 읽어보세요. 여러분 컴퓨터 공학자 아닙니까. 그러면 일반인과 차이가 있어야 하지않겠습니까? 컴퓨터 공학자라면 반드시 읽어보셔야 할 글 중 하나니까 시간 나실 떄 그 전문을 꼭 읽어보세요. 

  - 그다음 저는 (튜링에 관한 책)

  - 여럽누 미국에서는 19X0 대에(『계산기는 어떻게 인공ㄴ지능이 되었을까?』 참고) 늘어나느 계산량을 감당하기 위해 수많은 살마들을 고용하고 계산기 사ㅛㅇ법을 가르쳤습니다. 프로그래밍과 컴퓨터 공학의 본질을 이해하지 못한다면 당신은 단지 이와 같은 계산기의 사용법을 익힌 그 당시 미국에 고용된 사람들과 ㄱ다를 것이 전혀 없습니다. 

    왜냐하면 기술의 본질을 모르기때문에 새로운것을 창조해내거나 앞서나갈 수 없기때문이죠.

    - 또한 다가올 시대에서 이끌려다니기만할 것입니다. 왜냐하면 역사적으로 모든 순간 속에서  모든 공간 속에서 "이해한 사람이 이해하지 못한 사람을 지배해왔고 이끌어왔고 앞서가갔기 때문" 이죠

  - 조금 인문학 적인 내용으로 이야기가 빠지긴 했는데 역사를 보려고 마음을 먹으신 분은 한가지 팁을 드리자면 역사 속에서 자신만의 철학을 세우세요. 본질이 뭐고 왜 역사가 이렇게 발전했고 ㅐㅑ자신만의 철학을 세우고, 수정해나가면됩니다.

    그렇게 역사를 공부하면서 오늘날까지, 즉 최신기술 까지 공부하셨다면 지금까지 쌓인 자신의 철학을 바타으로 미래를 예측하세요. 그리고 그 예측을 바탕으로 앞으로 나아갈 길을 창조하고 선택하는거죠

    저는 저만의 철학을 세ㅜ었습니다. 기술은 자연을 대체하는 것이고 그 자동화가 가속화되가다가 언젠가 초진응이 나타날것이다.

    그 자신만의 철학이 올지않다고 드러났다고 해도 부끄러워하지 않아도 되고 기죽을 필요 없습니다. 그 철학ㄹ을 수정하면 됩니다. 수학 발전상을 보면 인류는 처음에 진리라고 믿었던 이론을 세웠짖맘ㄴ 그 이론이 틀렸다는 것이 드러났고 그 이론들을 수정해야만 했습ㅂ니다.

    (그러므로  인간에게 철학이 필요하다-왜냐면앞으로의 길을 선택해야 하기 때문에 따라서 철학을 세워야 하고  그 엄밀함이 부족하다고 드러났다고 해도 부끄러워할 이유가 없다 고치면 된다 는 공리를 기록해둬야함).

- 휴학의 중요성 설명 

  - 휴학하고 어떤 공부해얗 ㅏ는지 나의 팁.

  - 어떤 책 추천.

- 우리학교 수학 책에는 안나와있는 수학 개념이나 좀 부실한 수학 책말하면서 

  가령 야코비 행렬... 내가 산 수학 전공 교재 추천도 좋을듯.

- 선배 인터뷰 분야별로 

  - 가령 안드로이드-승미니형/푸름님, 웹-재워니형, 대학원-지유니, 인공지능-천명씨?, 창ㄴ업-예달미 혁민이형? 아님 해인이-소마

  - 간단한 질문 딱 3 가지만 인터뷰! 어떻게 공부했는지, 그 분야에 어떤 비전이 있었는지, 현재 어떤 상태인지

- 기술이란 자연을 대체하는것? 

  - 기술의 재정의 창조물..

  - 기술공학물을 1차 대체물, 전혀 새로운 창조물로 구별할 수 있음.

- 프로그래머란 코드로 자연을 대체하거나 전혀 새로운 창조물을 만들어내는것. 

- 실례 

  은행 사업 

  무한대 서점이 망한 것... 부익부 빈익빈 현상 가속화 설명! 

  인공지능이란 인간의 뇌의 뉴런을 코드로 대체..

  --> 예측 만약 여러분이 어떤 분야에서 필요한 기술을 만들고 싶다? 그 분야의 자연대상을 대체하면됨. 혹은 전혀 새로운 창조물을 만들어낼 수 있음.

- 모든 자연대상은 연결되어있으므로 동떨어진 곳도 해킹가능하다는 것 보여주기. 

- 그러면 왜 역사를 살펴보는가? 모든 대상에는 인과관계가 있고 프로그래머의 기본과 근본에 대하여 알기 위해서는 그 본질과 원류에 대한 이해가 필요하다. 그렇다면 역사를 알아야 하는 것. 즉 인문학........ 인문학에 대한 중요성은 또 다시 강조하겠음. 심지어 박사들도 영어로 "Philosophy" 로써 철학박사입니다. ㄱ즉 컴퓨터 박사란 "컴퓨터 철학 박사" 즉 인문학 박사라는 의미가 원래 본질적 의미라는 거죠. 

- 결국 모든 프로그래밍 언어는 4 가지로 압축되는데 그것들은 각자 추상적 의미를 지닙니다. 가령 덧셈은 자연대상을 더하는 모든 개별대상의 추상대상물인거죠. 이 추상대상물이 어떤 의미로도 특수화될 수 있기 때문에 그렇게 다양한 자연대상들을 대체할 수 있는 겁니다. ㅐ

- 수학사상사 / 괴델의 증명 / 괴델-에셔-바흐 / 레이커즈와일 "특이점은 온다" / "왜 우리는 필요없는 존재가 될 것인가?" 

  - 이 책을 강력하게 강력하게 강력하게 궝뉴합니다. 2000년 세월의 지식 발저 ㄴ위에 서시고, 미래학에 대한 통찰을 얻으세요 . 

  - 그리고 이 책들에 대한 간략한 설명.

  - 이 책들이 주는 의미에 대한 간략한 설명. 

  - 진짜 이 책 다 읽으면... 너무 좋아서 어떻게 추천을 해드려야 할지, 진짜 다 읽으면 밥 사드릴께요. 그정도로 너무 좋은 책들입니다. 컴퓨터 공학도가, 특히 인공지능 분야로 갈 사람은 반드시 읽어야 할 책이에요.

- 싸강때문에 이번학기가 역대급으로 힘들었다고 함. GBC 는 난이도를 대폭 낮춰서 숙제도 없고 시험도 없다는 것 강조해주자. 

- 제가 군생활을 할 때 정말 뛰어난 화이트 해커들이 많았어요. 그 사람들이 자기가 찾은 취약점을 보여주면서 이런 식으로 시스템을 해킹할 수 있다는 것을 막 알려줬었죠. 하지만 한편으로 어떤 엄청나게 위험하거나 중요한 취약점은 잘 알려주지 않으려한다는 것도 알게 되었어요. 저는 그것을 보고 생각했죠. 아, 사람들이 알려주지 않는 가장 중요하고 결국에 가장 크리티컬한 사실은 스스로 알아내야만 하는구나.

  그래서 저는 고민했습니다. 세상 모든 취약점을 포괄할 수 있는 학습법이 있을까? 어떻게 접근해야할까? 역사. 바로 역사가 모든 것을 포괄할 수 있ㅇ습니다. 그리고 역사로부터 발전되어온 발전 원리를 이해한다면 나도 새로운 지식을 발전시킬 수 있구나.! 라고.

  - 현재의 컴퓨터로 이르기까지의 수학 역사를 가볍게 읊어주는 것도 나쁘지 않겠다. 도움 많이 줄 수 있겠다. 